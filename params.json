{"name":"OTR.js","tagline":"Off-the-Record Messaging Protocol implemented in JavaScript","body":"[![Build Status](https://travis-ci.org/arlolra/otr.svg?branch=master)](https://travis-ci.org/arlolra/otr)\r\n\r\n[Off-the Record Messaging Protocol](http://www.cypherpunks.ca/otr/) in JavaScript\r\n==================================================\r\n\r\n### Warning\r\n\r\nThis library hasn't been properly vetted by security researchers. Do not use\r\nin life and death situations!\r\n\r\n### Install\r\n\r\nInclude the build files on the page,\r\n\r\n    <!-- Load dependencies -->\r\n    <script src=\"build/dep/bigint.js\"></script>\r\n    <script src=\"build/dep/crypto.js\"></script>\r\n    <script src=\"build/dep/eventemitter.js\"></script>\r\n\r\n    <!-- Load otr.js or otr.min.js -->\r\n    <script src=\"build/otr.min.js\"></script>\r\n\r\nHere's an [example](https://github.com/arlolra/otr/blob/master/test/browser.html) use in the browser.\r\n\r\nAlthough this is a client library, it can be used [on the server](https://github.com/arlolra/otr/blob/master/test/xmpp.js).\r\n\r\n    npm install otr\r\n\r\nAnd then,\r\n\r\n    var DSA = require('otr').DSA\r\n    var OTR = require('otr').OTR\r\n\r\n### Build\r\n\r\nThe contents of `build/` are the result of calling `make build` and are only\r\nupdated with releases. Please submit patches against `lib/` and `vendor/`.\r\n\r\n### Release\r\n\r\nThe normal flow for making a release is as follows,\r\n\r\n    make test\r\n    // bump the version numbers in package.json / bower.json\r\n    make build\r\n    git changelog  // cleanup the changelog\r\n    git commit -m \"bump version\"\r\n    git tag -a vX.X.X -m \"version X.X.X\"\r\n    git push origin master\r\n    git push --tags\r\n    npm publish\r\n    // update github releases and pages\r\n\r\n### Usage\r\n\r\n**Initial setup**: Compute your long-lived key beforehand. Currently this is\r\nexpensive and can take several seconds.\r\n\r\n    // precompute your DSA key\r\n    var myKey = new DSA()\r\n\r\nFor each user you're communicating with, instantiate an OTR object.\r\n\r\n    // provide options\r\n    var options = {\r\n        fragment_size: 140\r\n      , send_interval: 200\r\n      , priv: myKey\r\n    }\r\n\r\n    var buddy = new OTR(options)\r\n\r\n    buddy.on('ui', function (msg, encrypted, meta) {\r\n      console.log(\"message to display to the user: \" + msg)\r\n      // encrypted === true, if the received msg was encrypted\r\n      console.log(\"(optional) with receiveMsg attached meta data: \" + meta)\r\n    })\r\n\r\n    buddy.on('io', function (msg, meta) {\r\n      console.log(\"message to send to buddy: \" + msg)\r\n      console.log(\"(optional) with sendMsg attached meta data: \" + meta)\r\n    })\r\n\r\n    buddy.on('error', function (err, severity) {\r\n      if (severity === 'error')  // either 'error' or 'warn'\r\n        console.error(\"error occurred: \" + err)\r\n    })\r\n\r\n**New message from buddy received**: Pass the received message to the `receiveMsg`\r\nmethod.\r\n\r\n    var rcvmsg = \"Message from buddy.\"\r\n    var meta = \"optional some meta data, like delay\"\r\n    buddy.receiveMsg(rcvmsg, meta)\r\n\r\n**Send a message to buddy**: Pass the message to the `sendMsg` method.\r\n\r\n    var newmsg = \"Message to userA.\"\r\n    var meta = \"optional some meta data, like message id\"\r\n    buddy.sendMsg(newmsg, meta)\r\n\r\n**Going encrypted**: Initially, messages are sent in plaintext. To manually\r\ninitiate the authenticated key exchange.\r\n\r\n    buddy.sendQueryMsg()\r\n\r\nAlternatively, one can set the policy `REQUIRE_ENCRYPTION` and send a plaintext\r\nmessage. This will store the message, initiate the authentication and then,\r\nupon success, send it out.\r\n\r\n    buddy.REQUIRE_ENCRYPTION = true\r\n    buddy.sendMsg('My plaintext message to be encrypted.')\r\n\r\nAnother policy, `SEND_WHITESPACE_TAG`, will append tags to plaintext messages,\r\nindicating a willingness to speak OTR. If the recipient in turn has set the\r\npolicy `WHITESPACE_START_AKE`, the AKE will be initiated.\r\n\r\n**Close private connection**: To end an encrypted communication session,\r\n\r\n    buddy.endOtr(function() {\r\n      // calls back when the 'disconnect' message has been sent\r\n    })\r\n\r\nwill return the message state to plaintext and notify the correspondent.\r\n\r\n**Options**: A dictionary of the current options accepted by the OTR constructor.\r\n\r\n    var options = {\r\n\r\n      // long-lived private key\r\n      priv: new DSA(),\r\n\r\n      // turn on some debuggin logs\r\n      debug: false,\r\n\r\n      // fragment the message in case of char limits\r\n      fragment_size: 140,\r\n\r\n      // ms delay between sending fragmented msgs, avoid rate limits\r\n      send_interval: 200\r\n\r\n    }\r\n\r\n### Status\r\n\r\nA listener can be attached for status changes. These are non-standard codes,\r\nspecific to this OTR library, indicating various things like the AKE success.\r\n\r\n    buddy.on('status', function (state) {\r\n      switch (state) {\r\n        case OTR.CONST.STATUS_AKE_SUCCESS:\r\n          // sucessfully ake'd with buddy\r\n          // check if buddy.msgstate === OTR.CONST.MSGSTATE_ENCRYPTED\r\n          break\r\n        case OTR.CONST.STATUS_END_OTR:\r\n          // if buddy.msgstate === OTR.CONST.MSGSTATE_FINISHED\r\n          // inform the user that his correspondent has closed his end\r\n          // of the private connection and the user should do the same\r\n          break\r\n      }\r\n    })\r\n\r\n### Policies\r\n\r\nTo be set on a per-correspondent basis. The defaults are as follows:\r\n\r\n    // Allow version 2 or 3 of the OTR protocol to be used.\r\n    ALLOW_V2 = true\r\n    ALLOW_V3 = true\r\n\r\n    // Refuse to send unencrypted messages.\r\n    REQUIRE_ENCRYPTION = false\r\n\r\n    // Advertise your support of OTR using the whitespace tag.\r\n    SEND_WHITESPACE_TAG = false\r\n\r\n    // Start the OTR AKE when you receive a whitespace tag.\r\n    WHITESPACE_START_AKE = false\r\n\r\n    // Start the OTR AKE when you receive an OTR Error Message.\r\n    ERROR_START_AKE = false\r\n\r\n### Instance Tags\r\n\r\nThese are intended to be persistent and can be precomputed.\r\n\r\n    var myTag = OTR.makeInstanceTag()\r\n    var options = { instance_tag: myTag }\r\n\r\n    var buddy = new OTR(options)\r\n\r\n### Fingerprints\r\n\r\nOTR public key fingerprints can be obtained as follows:\r\n\r\n    // assume you've gone through the ake with buddy\r\n    var buddy = new OTR({ priv: myKey })\r\n    // buddy.msgstate === OTR.CONST.MSGSTATE_ENCRYPTED\r\n\r\n    // for my key, either one of the following\r\n    myKey.fingerprint()\r\n    // or,\r\n    buddy.priv.fingerprint()\r\n\r\n    // for their key\r\n    buddy.their_priv_pk.fingerprint()\r\n\r\n### Socialist Millionaire Protocol\r\n\r\nAt any time after establishing encryption, either party can initiate SMP to\r\ndetect impersonation or man-in-the-middle attacks. A shared secret,\r\nexchanged through an out-of-band channel prior to starting the conversation,\r\nis required.\r\n\r\n    var secret = \"ghostbusters\"\r\n    buddy.smpSecret(secret)\r\n\r\nA question can be supplied, as a reminder of the shared secret.\r\n\r\n    var question = \"who are you going to call?\"\r\n    buddy.smpSecret(secret, question)\r\n\r\nIf you plan on using SMP, as opposed to just allowing fingerprints for\r\nverification, provide on optional callback when initiating OTR,\r\notherwise a no-opt is fired.\r\n\r\n    var buddy = new OTR()\r\n\r\n    buddy.on('smp', function (type, data, act) {\r\n      switch (type) {\r\n        case 'question':\r\n          // call(data) some function with question?\r\n          // return the user supplied data to\r\n          // userA.smpSecret(secret)\r\n          break\r\n        case 'trust':\r\n          // smp completed\r\n          // check data (true|false) and update ui accordingly\r\n          // act (\"asked\"|\"answered\") provides info one who initiated the smp\r\n          break\r\n        case 'abort':\r\n          // smp was aborted. notify the user or update ui\r\n        default:\r\n          throw new Error('Unknown type.')\r\n      }\r\n    })\r\n\r\nBoth users should run the SMP to establish trust. Further, it should be run each time a partner presents a fresh long-lived key.\r\n\r\n### Private Keys\r\n\r\nTo export a private, long-lived key:\r\n\r\n    var myKey = new DSA()\r\n    var string = myKey.packPrivate()  // returns a Base64 encoded string\r\n\r\nIt can then be imported as follows,\r\n\r\n    string = \"AAAAAACA4COdKHpU/np9F8EDdnGiJJmc89p ... I9BzTkQduFA7ovXAMY=\"\r\n    myKey = DSA.parsePrivate(string)\r\n\r\nImporting the (somewhat) standard libotr s-expression format works as well,\r\n\r\n    // in node.js\r\n    var fs = require('fs')\r\n    string = fs.readFileSync(\"~/.purple/otr.private_key\", 'utf8')\r\n\r\n    // leaving out the terminal backslashes needed for multiline strings in js\r\n    string = \"(privkeys\r\n      (account\r\n        (name \"foo@example.com\")\r\n        (protocol prpl-jabber)\r\n        (private-key\r\n          (dsa\r\n            (p #00FC07 ... 2AEFD07A2081#)\r\n            (q #ASD5FF ... LKJDF898DK12#)\r\n            (g #535E3E ... 1E3BC1FC6F26#)\r\n            (y #0AC867 ... 8969009B6ECF#)\r\n            (x #14D034 ... F72D79043216#)\r\n          )\r\n        )\r\n      )\r\n    )\"\r\n\r\n    myKey = DSA.parsePrivate(string, true)\r\n\r\n### Extra Symmetric Key\r\n\r\nIn version 3 of the protocol, an extra symmetric key is derived during the AKE. This may be used for secure communication over a different channel (e.g., file transfer, voice chat).\r\n\r\n    var filename = \"test.zip\"\r\n    var buddy = new OTR()\r\n    buddy.sendFile(filename)\r\n    buddy.on('file', function (type, key, filename) {\r\n      // type === 'send'\r\n      // key should be used to encrypt filename\r\n      // and sent through a different channel\r\n    })\r\n\r\nOn the other end,\r\n\r\n    var friend = new OTR()\r\n    friend.on('file', function (type, key, filename) {\r\n      // type === 'receive'\r\n      // decrypt filename with key, once received\r\n    })\r\n\r\n### WebWorkers\r\n\r\nSome support exists for calling computationally expensive work off the main\r\nthread. However, some feedback on these APIs would be appreciated.\r\n\r\n    // generate a DSA key in a web worker\r\n    DSA.createInWebWorker(null, function (key) {\r\n\t\t\tvar buddy = new OTR({\r\n\t\t\t\tpriv: key,\r\n\t\t\t\t// setting `smw` to a truthy value will perform the socialist\r\n\t\t\t\t// millionaire protocol in a webworker.\r\n\t\t\t\tsmw: {}\r\n\t\t\t})\r\n\t  })\r\n\r\nWebWorkers don't have access to `window.crypto.getRandomValues()`, so they will\r\nneed to include Salsa20.\r\n\r\n    <script src=\"build/dep/salsa20.js\"></script>\r\n\r\n### Links\r\n\r\nSpec:\r\n\r\n- http://www.cypherpunks.ca/otr/Protocol-v3-4.0.0.html\r\n- http://www.cypherpunks.ca/otr/Protocol-v2-3.1.0.html\r\n- See: `specs/`\r\n\r\nUsing:\r\n\r\n- [crypto-js](http://code.google.com/p/crypto-js/)\r\n- [bigint.js](http://leemon.com/crypto/BigInt.html)\r\n- [salsa20.js](https://gist.github.com/dchest/4582374)\r\n- [eventemitter.js](https://github.com/Wolfy87/EventEmitter)\r\n\r\n### In The Wild\r\n\r\nA sampling of projects that use this library:\r\n\r\n- [Cryptocat](https://github.com/cryptocat/cryptocat)\r\n- [Yabasta](https://github.com/jonkri/yabasta)\r\n- [Diaspora](https://github.com/sualko/diaspora)\r\n- [Converse.js](https://github.com/jcbrand/converse.js)\r\n- [WebRTCCopy](https://github.com/erbbysam/webRTCCopy)\r\n- [OTRon](https://github.com/osnr/otron)\r\n- [ojsxc (owncloud)](https://github.com/sualko/ojsxc)\r\n- [sjsxc (SOGo)](https://github.com/sualko/sjsxc)\r\n- [LoquiIM](https://loqui.im/)\r\n- [Salut à Toi](http://salut-a-toi.org/) ([Python wrapper][0] for Pyjamas)\r\n- [HackTunnel](https://github.com/devhq-io/hacktunnel)\r\n\r\n[0]: http://repos.goffi.org/libervia/file/tip/src/browser/sat_browser/otrjs_wrapper.py\r\n\r\n### Donate\r\n\r\nBitcoins: 1BWLnnig89fpn8hCcASd2B1YbfK6j1vtX3\r\n\r\n### License\r\n\r\nMPL v2.0\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}